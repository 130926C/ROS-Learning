### demo10
---

### 在启动节点的时候为参数服务器设置一个参数。

实验目的：
1. 启动时添加参数到参数服务器
2. 运行时添加参数到参数服务器

**FILE：set_param_c.cpp**

方法一：用命令行的方式在运行时可以直接设置
```shell
$ rosrun demo start_param_node _length:=5
```
格式：下划线_变量名:=变量值


方法二：使用argc和argv的方式添加参数
（详见代码）

----

### 节点重复启动。

实验目的：
1. 让节点复用

**FILE：multi_node_c.cpp**

在ROS中，同名的节点不能同时启动，后启动的会将前面的节点关闭后再运行，如果想要节点复用的话，在代码中这样写：
```cpp
ros::init(argc, argv, "multi_node", ros::init_options::AnonymousName);
```
参数 ros::init_options::AnonymousName 会给这个节点后面加一个随机数。

先后启动两个节点
```shell
$ rosrun demo multi_node
$ rosrun demo multi_node
```
使用命令查看当前有哪些节点正在运行
```shell
$ rosnode list 
	/multi_node_1650179047404718375
	/multi_node_1650179080983917793
```
可以发现，运行的两个节点都被赋予了一串随机数后缀。

实验结果：
1. ros::init_options::AnonymousName 通过增加节点名后缀来实现复用

-------

### 发布者对象保留最后一次的消息给迟到的订阅者

**FILE：pub_latch_c.cpp, sub_latch_c.cpp**

实验目的：
1. 验证发布方停止发布后订阅方一（最早启动）、订阅方二（中途启动）、订阅方三（最晚启动）能否收到发布方最后一条信息。
2. 当发布方shutdown的时候，上述三个订阅方能否收到信息。
3. 确定话题的生命周期。


实验结果：
1. 发布者发布完直接退出，最晚启动的节点没有收到任何信息；
2. 发布者发布完 rate.sleep(), 最完启动的节点可以收到最后一条信息；
3. 话题的声明周期是从第一个注册/关注的节点开始，到最后一个节点被kill掉结束，即便发布者参数latch=true，如果所有订阅的节点都关闭了，又来一个新的订阅者，那么这个订阅者也无法获得之前的话题内容。但要注意的是，此时这个订阅者会重新拉起一个话题，只不过这个话题里面没有东西。

----

### spin & spinonce 

**FILE：pub_spin_c.cpp**

处理回调，当回调函数条件被触发的时候会自发调用。

spinonce()：回调一次，处理完后就执行spinonce后面的代码
spin()：循环回调，一直循环处理回调函数，spin后面的代码不会被调用

实验目的：
1. 验证spinonce，spin后面的代码会不会被调用；
2. 检查spinonce、spin前面的代码会不会被调用；


实验结果：
|  |上文有回调(循环体外)|上文无回调(循环体外)|上文有回调(循环体内)|上文无回调(循环体内)|
|---|----|---|----|----|
|spin|循环执行回调函数|挂起|跳出循环体执行回调|挂起|
|spinOnce|执行一次回调函数|继续执行|跳出循环体执行一次再回来|继续循环|

-----




